# TODO: Fix layout in target tab
# TODO: Implement some kind of progress on target page, and in results table
# TODO: Put response code/size/etc in results
# TODO: Tidy up/theme instructions
# TODO: Implement option for parallel requests

from burp import (IBurpExtender, ITab, IContextMenuFactory,
                  IMessageEditorController)

from collections import Counter
import re
from thread import start_new_thread
from time import time

from javax.swing import (JTabbedPane, JPanel, JLabel, Box, JTextField,
                         JTextArea, JCheckBox, JMenuItem, JButton, JTable,
                         JScrollPane)
from javax.swing.table import DefaultTableModel
from java.awt import BorderLayout

EXTENSION_NAME = "Multi-Time Based Attacker"
INSTRUCTIONS = (
    "<html>" +
    "<h1>" + EXTENSION_NAME + "</h1>"
    "<h2>About this extension</h2>" +
    EXTENSION_NAME + " is a Burp extension that can be used to perform timing "
    "attacks over an unreliable network such as the internet. The attack mode "
    "is similar to the \"sniper\" mode in burp intruder, but instead of "
    "sending a single request for every payload, it is able to send multiple "
    "requests for each payload and show the minimum and maximum times taken "
    "to receive a response as well as showing average times.<br><br>"
    "The extension sends HTTP(S) requests sequentially to reduce the chance "
    "affecting the time the server takes to respond by overloading it.<br><br>"
    "<h2>Using this extension</h2>"
    "<ol><li>Start by sending a request to the extension by right clicking on "
    "a request anywhere in Burp and choosing \"Send To " + EXTENSION_NAME +
    "\" This will populate the \"Target\" tab in the extension.</li>"
    "<li>Select the parts of the request that should be replaced with the "
    "payloads then click the \"Add Payload At Position\" button. This will "
    "add symbols at the start and end positions where the payload will be "
    "inserted.</li>"
    "<li>Choose how many requests to make for each payload</li>"
    "<li>Type or copy/paste the payloads into the \"Payloads\" text area. "
    "Place a single payload on each new line.</li>"
    "<li>Hit the \"Start Attack\" button. Results will be displayed in the "
    "results tab</li></ol>"
    "<h2>Troubleshooting</h2>"
    "Extensions such as Logger++ (available from the BApp store) will show "
    "requests and responses that have been generated by this extension.<br>"
    "<br>"
    "This extension was written by "
    "<a href=\"mailto:graeme.robinson@mwrinfosecurity.com\">"
    "graeme.robinson@mwrinfosecurity.com</a>"
    "</html>"
)

def mean(values):
    return sum(values) / len(values)

def median(values):
    l = len(values)
    values.sort()
    if l % 2 != 0:
        # Odd number of values, so chose middle one
        return values[l//2]
    else:
        # Even number of values, so mean of middle two
        return mean([values[l//2], values[(l//2)-1]])

def mode(values):
    c = Counter(values)
    modes = [str(k) for k, v in c.items() if v == max(c.values())]
    return ", ".join(modes)

class BurpExtender(IBurpExtender, ITab, IContextMenuFactory, IMessageEditorController):

    # Implement IBurpExtender
    def registerExtenderCallbacks(self, callbacks):

        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()

        callbacks.setExtensionName(EXTENSION_NAME)

        callbacks.registerContextMenuFactory(self)

        self._tabbedPane = JTabbedPane()

        targetViewer = JPanel(BorderLayout())
        verticalBox = Box.createVerticalBox()

        hostHorizontalBox = Box.createHorizontalBox()
        hostHorizontalBox.add(JLabel("Host:"))
        self._hostTextField = JTextField("", 10)
        hostHorizontalBox.add(self._hostTextField)
        verticalBox.add(hostHorizontalBox)

        portHorizontalBox = Box.createHorizontalBox()
        portHorizontalBox.add(JLabel("Port:"))
        self._portTextField = JTextField("", 10)
        portHorizontalBox.add(self._portTextField)
        verticalBox.add(portHorizontalBox)

        transportHorizontalBox = Box.createHorizontalBox()
        self._protocolCheckBox = JCheckBox()
        transportHorizontalBox.add(self._protocolCheckBox)
        transportHorizontalBox.add(JLabel("Use HTTPS"))
        verticalBox.add(transportHorizontalBox)

        verticalBox.add(JLabel("Request:"))
        self._messageEditor = callbacks.createMessageEditor(self, True)
        messageEditorComponent = self._messageEditor.getComponent()
        verticalBox.add(messageEditorComponent)

        verticalBox.add(JButton(
            "Add Payload At Position", actionPerformed=self._addPayload))

        verticalBox.add(JButton(
            "Clear Payloads", actionPerformed=self._clearPayloads))

        numReqHorizontalBox = Box.createHorizontalBox()
        numReqHorizontalBox.add(JLabel("Number of Requests:"))
        self._numReqTextField = JTextField("5", 10)
        self._numReqTextField.setColumns(10)
        numReqHorizontalBox.add(self._numReqTextField)
        verticalBox.add(numReqHorizontalBox)

        verticalBox.add(JLabel("Payloads:"))
        self._payloadTextArea = JTextArea()
        verticalBox.add(self._payloadTextArea)

        verticalBox.add(JButton(
            "Start Attack", actionPerformed=self._startAttack))

        targetScrollPane = JScrollPane(verticalBox)

        targetViewer.add(targetScrollPane, BorderLayout.NORTH)

        resultsViewer = JPanel(BorderLayout())

        self._resultsTableModel = DefaultTableModel(
            ["Payload", "Number of Requests", "Minimum",
             "Maximum", "Mean", "Median", "Mode"], 0)

        resultsTable = JTable(self._resultsTableModel)
        resultsTable.setAutoCreateRowSorter(True)
        resultsScrollPane = JScrollPane(resultsTable)
        resultsViewer.add(resultsScrollPane)

        instructionsViewer = JPanel(BorderLayout())
        instructionsLabel = JLabel(INSTRUCTIONS)
        instructionsScrollPane = JScrollPane(instructionsLabel)
        instructionsViewer.add(instructionsScrollPane, BorderLayout.NORTH)

        self._tabbedPane.addTab("Target", targetViewer)
        self._tabbedPane.addTab("Results", resultsViewer)
        self._tabbedPane.addTab("Instructions", instructionsViewer)

        callbacks.addSuiteTab(self)

    # Implement ITab
    def getTabCaption(self):
        return EXTENSION_NAME

    def getUiComponent(self):
        return self._tabbedPane

    # Implement IMessageEditorController
    def getHttpService(self):
        self._updateClassFromUI()
        return self._httpService

    def getRequest(self):
        # Strangely this doesn't seem necessary; returning None also works.
        self._updateClassFromUI()
        return self._request

    def getResponse(self):
        return None

    # Implement IContextMenuFactory
    def createMenuItems(self, contextMenuInvocation):
        print "Being queried for context menu items"
        messages = contextMenuInvocation.getSelectedMessages()

        # Only add menu item if a single request is selected
        if len(messages) == 1:
            self._contextMenuData = messages
            menu_item = JMenuItem(
                "Send to {}".format(EXTENSION_NAME),
                actionPerformed = self._contextMenuItemClicked
            )
            print "Context menu item added"
            return [menu_item]
        else:
            print "Not adding context menu item this time"

    def _contextMenuItemClicked(self, _):
        print "Context Menu Item Clicked"
        httpRequestResponse = self._contextMenuData[0]

        # Update class variables with request data
        self._httpService = httpRequestResponse.getHttpService()
        self._request = httpRequestResponse.getRequest()

        # Update fields in tab
        self._hostTextField.setText(self._httpService.getHost())
        self._portTextField.setText(str(self._httpService.getPort()))
        self._protocolCheckBox.setSelected(
            True if self._httpService.getProtocol() == "https" else False)
        self._messageEditor.setMessage(self._request, True)

    def _startAttack(self, _):

        print "Attack Start Button Clicked!"

        # Set class variables from values in UI
        self._updateClassFromUI()

        # Clear results table
        self._resultsTableModel.setRowCount(0)

        self._responses = {}
        payloads = set(self._payloads.splitlines())
        start_new_thread(self._makeHttpRequest, (payloads,))

    def _makeHttpRequest(self, payloads):

        for payload in payloads:
            self._responses[payload] = []
            # Stick payload into request at specified position
            request = re.sub("\xa7[^\xa7]*\xa7", payload, self._request)
            request = self._updateContentLength(request)
            for _ in xrange(self._numReq):
                # Make request and work out how long it took. This method is
                # crude, but it's as good as we can get with current Burp APIs
                # See https://bit.ly/2JX29Nf
                startTime =time()
                self._callbacks.makeHttpRequest(
                    self._httpService, request)
                endTime = time()
                duration = endTime - startTime

                self._responses[payload].append(duration)

                # If all responses for this payload have
                #  been added to array, add to results table.
                if len(self._responses[payload]) == self._numReq:
                    # Add results to results tab
                    results = self._responses[payload]
                    numReqs = self._numReq
                    meanTime = mean(results)
                    medianTime = median(results)
                    modeTime = mode(results)
                    minTime = min(results)
                    maxTime = max(results)
                    rowData = [payload, numReqs, minTime, maxTime,
                               meanTime, medianTime, modeTime]
                    self._resultsTableModel.addRow(rowData)

    def _updateClassFromUI(self):
        host = self._hostTextField.text
        port = int(self._portTextField.text)
        protocol = "https" if self._protocolCheckBox.isSelected() else "http"
        self._httpService = self._helpers.buildHttpService(host, port, protocol)
        self._request = self._updateContentLength(self._messageEditor.getMessage())
        self._numReq = int(self._numReqTextField.text)
        self._payloads = self._payloadTextArea.text

    def _addPayload(self, _):
        request = self._messageEditor.getMessage()
        selection = self._messageEditor.getSelectionBounds()
        if selection[0] == selection[1]:
            # No text selected so in/out points are same
            request.insert(selection[0], 0xa7)
            request.insert(selection[1], 0xa7)
        else:
            request.insert(selection[0], 0xa7)
            request.insert(selection[1]+1, 0xa7)
        self._messageEditor.setMessage(request, True)

    def _clearPayloads(self, _):
        request = self._messageEditor.getMessage()
        request = self._helpers.bytesToString(request).replace("\xa7", "")
        self._messageEditor.setMessage(request, True)

    def _updateContentLength(self, request):
        # Dirty trick (toggle type twice) to make burp fix the
        # Content-Length header
        request = self._helpers.toggleRequestMethod(request)
        request = self._helpers.toggleRequestMethod(request)
        return request
